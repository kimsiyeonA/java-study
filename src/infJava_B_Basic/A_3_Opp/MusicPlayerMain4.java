package infJava_B_Basic.A_3_Opp;

// 객체 지향 프로그래밍 - 실행 클래스

// 지금까지 개발한 음악 플레이어는 데이터와 기능이 분리되어 있었다.
// 이거를 음악플레이어 라고 하기에는 애매하다.
// 데이터와 기능을 하나로 묶어서 음악 플레이어라는 개념을 온전히 하나에 클래스에 담아야 한다.

// 프로그램의 실행 순서보다는 음악 플레이어 클래스를 만드는 것에 집중해야한다.
// 음악 플레이어가 어떤 속성을 가지고 어떤 기능을 제공하는지 부분에 초점을 맞춰야한다.

// 이것을 어떻게 사용할지는 분리해서 생각해야한다.
// 음악 플레이어를 만드는 개발자와 음악 플레이어를 사용하는 개발자가 분리되어 있다고 생각하면 된다.

// 실제 존재하는 음악플레이어의 속성과 기능을, 실제 객체를 비슷하게 프로그램으로 만드는 것이 객체 지향 프로그램이다.

public class MusicPlayerMain4 {
    public static void main(String[] args) {
        MusicPlayer player = new MusicPlayer();
        //음악 플레이어 켜기
        player.on();
        //볼륨 증가
        player.volumeUp();
        //볼륨 증가
        player.volumeUp();
        //볼륨 감소
        player.volumeDown();
        //음악 플레이어 상태
        player.showStatus();
        //음악 플레이어 끄기
        player.off();
    }
}

// MusicPlayer 객체를 생성하고 필요한 기능(메서드)을 호출하기만 하면된다.
// 필요한 모든 것은 MusicPlayer 안에 들어있다

// MusicPlayer 를 사용하는 입장에서는 MusicPlayer 의 데이터인 volume , isOn 같은 데이터는 전혀 사용하지 않는다.
// MusicPlayer 를 사용하는 입장에서는 이제 MusicPlayer 내부에 어떤 속성(데이터)이 있는지 전혀 몰라도 된다.
// MusicPlayer 를 사용하는 입장에서는 단순하게 MusicPlayer 가 제공하는 기능 중에 필요한 기능을 호출해서 사용하기만 하면 된다.

// 캡슐화
// MusicPlayer 를 보면 음악 플레이어를 구성하기 위한 속성과 기능이 마치 하나의 캡슐에 쌓여있는 것 같다.
// 이렇게 속성과 기능을 하나로 묶어서 필요한 기능을 메서드를 통해 외부에 제공하는 것을 캡슐화라 한다.

// 객체 지향 프로그래밍 덕분에 음악 플레이어 객체를 사용하는 입장에서 진짜 음악 플레이어를 만들고 사용하는 것 처럼 친숙하게 느껴진다.
// 그래서 코드가 더 읽기 쉬운 것은 물론이고, 속성과 기능이 한 곳에 있기 때문에 변경도 더 쉬워진다.
// 예를 들어서 MusicPlayer 내부 코드가 변하는 경우에 다른 코드는 변경하지 않아도 된다.
// MusicPlayer 의 volume 이라는 필드 이름이 다른 이름으로 변한다고 할 때 MusicPlayer 내부만 변경하면 된다.
// 또 음악 플레이어가 내부에서 출력하는 메시지를 변경할 때도 MusicPlayer 내부만 변경하면 된다.
// 이 경우 MusicPlayer 를 사용하는 개발자는 코드를 전혀 변경하지 않아도 된다.
// 물론 외부에서 호출하는 MusicPlayer 의 메서드 이름을 변경한다면 MusicPlayer 를 사용하는 곳의 코드도 변경해야 한다.